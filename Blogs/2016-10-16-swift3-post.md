---
layout: post
title: "Swift 3.0"
description: "记录 Swift 3.0 的笔记"
date: 2016-10-16
tags: [Swift]
comments: true
share: false
---

# 基础知识

* 类型
* 常量和变量
* 输出
* 注释
* 分号
* 数值型字面量
* 类型别名
* 元组
* 可选类型
* 错误处理

---

## 类型

> Swift 基础类型以及集合类型都是值类型。

* 基础类型
    * Int (Int8, Int16, Int32, Int64, UInt...)
    * Double (Float)
    * Bool
    * String (Character)
* 集合类型
    * Array
    * Set
    * Dictionary
* 元组 (Tuple)
    * (,)
* 可选类型
    * nil

## 常量和变量

> Swift 带有类型推断功能，属性的类型可以注明，也可以通过初始值推断。

* 常量: let <name>: <type> = <value>
* 变量: var <name>: <type><!,? or noting> = <value>

## 输出

```
public func print(_ items: Any..., separator: String = default, terminator: String = default)
```

## 注释

```
// 单行注释内容
/// 带 Xcode 代码提示的单行注释内容

/*
    多行注释内容
 */
/**
    带 Xcode 代码提示的多行注释内容
 */
```

## 分号

Swift 不强制要求使用分号，但是也可以使用，比如在同一行内些多条独立语句的时候。

## 数值型字面量

* 十进制数，没有前缀
* 二进制数，前缀是0b
* 八进制数，前缀是0o
* 十六进制数，前缀是0x

```
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

let paddedDouble = 000123.456      // 123.456
let oneMillion = 1_000_000         // 1000000
let justOverOneMillion = 1_000_000.000_000_1 // 1000000.0000001
```

## 类型别名

```
// typealias <New Type Name> = <Old Type Name>
typealias AudioSample = UInt16
```

## 元组 (Tuples)

把多个值组合成为一个复合值，元组内部的值可以是任意类型，不要求是相同类型。

```
let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")

let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// 输出 "The status code is 404"
print("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"

let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"

print("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
print("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"

let http200Status = (statusCode: 200, description: "OK")

print("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
print("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
```

## 可选类型 (optional)

使用 ? 和 ! 来表示可选类型。? 表示使用的时候可能为 nil, ! 表示使用的时候自动解包。

## 错误处理 (error handing)

```
// 定义可能报错的函数
func canThrowAnError() throws {
    
}

// 调用该函数
do {
    try canThrowAnError()
    // 没有错误抛出
} catch {
    // 有错误抛出
}
```

## 断言

```
// 当 condition 为 true 则不会触发断言，否则就触发。
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)
```

---

---

# 运算符 (Operators)

* 基本运算符
* 高级运算符

## 基本运算符 (Basic Operators)

* 赋值运算符 ( = )
* 正负号运算符 ( -, + )
* 算术运算符 ( +, -, *, /, % )
* 组合运算符 ( +=, -=, *=, /=, %= )
* 三元运算符 ( <条件> ? <true 返回值> : <false 返回值> )
* 比较运算符 ( ==, !=, >, <, >=, <=, ===, !== )
* 空值运算符 ( <可选类型> ?? <假如可选类型为空时的返回值> )
* 区间运算符 ( ..., ..< )
* 逻辑运算符 ( !, &&, || )

> Swift 中可以对浮点数进行求余运算。

---

## 高级运算符

---

---

# 字符串与字符

> 字符串是 struct 类型

```
// 字符
    let <name>: Character = "!"

// 初始化
    var <name>: String = String()
    var <name>: String = "Some String \(<value>) Other String"

// 字符串常用操作
    /*
        * 运算符 ( +, += )
        * 函数操作 ( append(), insert(), remove(), removeSubrange() )
        * 获取字符及字符数量 ( String.characters, String.characters.count )
    */

// Unicode
    /*
        * 转义字符
            * \0(空字符)    \\(反斜线)    \t(水平制表符)
            * \n(换行符)    \r(回车符)    \"(双引号)    \'(单引号)
        * Unicode 标量
            * \u{任意一到八位十六进制数且可用的 Unicode 位码}
    */

// String.Index 字符串索引
    let test = "This is a long String, and is end!"
                ^                                 ^
                test.startIndex                   test.endIndex
    // * 利用下标访问字符串
    test[test.startIndex]                       // T
    test[test.index(before: test.endIndex)]     // !
    test[test.index(after: test.startIndex)]    // h
    test[test.index(test.index, offsetBy: 5)]   // s
    test[test.endIndex]                         // 错误
    test.index(after: test.endIndex)            // 错误
    test[test.startIndex ..< test.index(test.startIndex, offsetBy: 6)] // This i

    // * 遍历下标
    for index in test.characters.indices {
        print(test[index])
    }
    // This is a long String, and is end!
```

---

---


# 集合类型

* Arrays
* Sets
* Dictionaries 

> Swift 中集合类型都是泛型
> 集合类型的数据类型必须明确

## Array<Element>

```
// 创建
    var <name>: [<type>] = [Type](count: <number>, repeatedValue: <init value>)

// 访问
    <array>[<index>]
    <array>[<Range>]

// 常用操作
    /*
        * 运算符 ( +, += )
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( append(), insert(), remove(), removeAll(), removeLast(), removeFirst() )
    */

// 遍历
    for value in array {
        /* do some thing */
    }

    for (index, value) in array.enumerate() {
        /* do some thing */
    }
```

---

## Set<Element>

> 集合类型必须遵守 Hashable 协议

```
// 创建
    var <name>: Set<<type>> = Set<<type>>()

// 常用操作
    /*
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( insert(), remove(), removeAll(), removeFirst(), contains() )
    */

// 遍历
    for value in set {
        /* do some thing */
    }

    for (index, value) in set.sorted() {
        /* do some thing */
    }

// 集合操作
    var a: Set<Int> = [1,2,3,4,5]
    var b: Set<Int> = [3,4,5,6,7]
    a.intersection(b)        // [3,4,5]         相交元素
    a.symmetricDifference(b) // [1,2,6,7]       非相交元素
    a.union(b)               // [1,2,3,4,5,6,7] 所有元素
    a.subtracting(b)         // [1,2]           a 中的非相交元素

// 集合运算
    * ==                        // 是否完全一致
    * a.isSubset(of: b)         // a 中的元素 b 是否都有
    * a.isSuperset(of: b)       // b 中的元素 a 是否都有
    * a.isStrictSubset(of: b)   // a 中的元素 b 是否都有，并且 a != b
    * a.isStrictSuperset(of: b) // b 中的元素 a 是否都有，并且 a != b
    * a.isDisjoint(with: b)     // a b 是否没有交集
```

---

## Dictionary<Hashable, Any>

> key 必须遵守 Hashable 协议

```
// 创建
    var <name>: Dictionary<<key type>, <value type>> = Dictionary<<key type>, <value type>>()

// 访问和修改
    <dic>[<key>] = <Any>? // 如果 Any 不为空则是新增或修改 key 值，否则就是删除 key 值。

// 常用操作
    /*
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( updateValue(), remove(), removeValue(), removeAll(), contains() )
    */

// 遍历
    for (key, value) in dic {
        /* do some thing */
    }

    for key in dic.keys.sorted() {
        /* do some thing */
    }

    for value in dic.values.sorted() {
        /* do some thing */
    }
```

---

---

# 控制流

* 循环
* 分支
* 控制转移语句

## 循环

```
// for-in

    for <value or _> in <array like 0 ..< 10, or [1,2,3]> {
        /* do some thing */
    }

// while

    while <条件> {
        /* do some thing */
    }

    repeat {
        
    } while <条件>

```

---

## 分支

```
// if

if <条件> {
    /* do some thing */
} else if <条件> {
    /* do some thing */
} else {
    /* do some thing */
}

// switch

    switch <值> {
    case <条件>:
        /* do some thing */
    case <条件>:
        /* do some thing */
    default:
        /* do some thing */
    }

    // 各种示例
        let value: Int = 10
        switch value {
        case 0: // 单一匹配
            /* do some thing */
        case 1, 2, 3: // 复合匹配
            /* do some thing */
        case 4 ..< 7: // 区间匹配
            /* do some thing */
        default:
            /* do some thing */
        }

        let tuple: (Int, Int) = (10, 10)
        switch tuple {
        case (0, 0): // 单一匹配
            /* do some thing */
        case (1, 1), (2, 2):            // 复合匹配
            /* do some thing */
        case (3 ..< 5, 4 ..< 6):        // 区间匹配
            /* do some thing */
        case (_, 7), (8, _):            // _ 匹配所有值，表示忽略
            /* do some thing */
        case (let x, 9):                // 忽略并获取 $0 值
            /* do some thing */
        case let (x, y):                // 忽略并获取 $0, $1 值
            /* do some thing */
        case let (x, y) where x == 7:   // 使用 where 添加限定条件
            /* do some thing */
        default: 
            /* do some thing */
        }

// guard

    guard <条件> else {
        <必须有 retrun, continue 等退出条件>
    }

    // 解包
    guard let <value> = <value>? else {
        <必须有 retrun, continue 等退出条件>
    }
```

---

##  控制转移语句

```
// continue 跳过当前循环中的后面部分，直接进入下一次循环

// break 跳出当前的循环

// return 退出当前的函数

// fallthrough switch 语句中使用，让某个 case 可以进入下一个 case.

// throw 错误抛出

// 循环标签

    <name>: while <条件> {
        /* do some thing */
        <name2>: while <条件> {
            /* do some thing */
            break name // 直接退出 name 循环
        }
    }

// Api 检查

    if #available(<platform name> <version>, <...>, *) {
        // statements to execute if the APIs are available
    } else {
        // fallback statements to execute if the APIs are unavailable
    }

    if #available(iOS 10, macOS 10.12, *) {
        /* iOS 使用 iOS 10 的 API, macOS 使用 macOS 10.12 的 API */
    } else {
        /* 其他版本的 Api */
    }

```

---

---

# 函数与闭包及其调用

* 函数
* 闭包
* 可选链

## 函数

函数定义: func <name>(<参数外部名> <参数内部名>: <inout> <参数类型> = <默认值> <可变参数 ...>) -> <返回值类型>

函数类型: (<参数类型>) -> <返回值参数>

嵌套函数: 函数中可以定义函数，该函数只有在函数内部有效。

---

## 闭包

闭包是自包含的代码库，可以在代码中被传递和使用。闭包可以捕获和存储其所在上下文中任意的常量和变量来使用，所以会导致引用计数 +1 从而有循环引用的风险。

全局函数是一个有名字但不会捕获任何值的闭包。嵌套函数是有名字并可以捕获函数内值的闭包。闭包表达式一般都是匿名闭包。

单表达式的闭包可以省略 retrun 关键字。

闭包内的参数在未定义的情况下可以使用 $0 来对参数名称进行缩写，$0 表示第一个参数， $1 表示第二个参数，以此类推。

闭包是引用类型的值。

@noescape 表示非逃逸闭包，限定了闭包的生命周期只能存在于当前函数当中。

@autoclosure 表示自动闭包，这种闭包不接受参数，并且由返回值。用于传递作为参数的表达式，并可以省略花括号。自动闭包都默认带了 noescape 属性，如果想要声明为可逃逸闭包则是 @autoclosure(escaping).

```
{ (<参数名>: <参数类型>) -> <返回值类型> in
    <闭包实现>
}

闭包在使用的时候可以有几种不同的方式，以 sorted 调用为例: 
    // 完整
    closures.sort(by: { (v0: Int, v1: Int) -> Bool in
        return v0 > v1
    })

    // 上下文推断
    closures.sort(by: { v0, v1 in
        return v0 > v1
    })

    // 隐式返回值
    closures.sort(by: { $0 > $1 })

    // 运算符函数返回
    closures.sort(by: >)

    // 尾闭包
    closures.sort { $0 > $1 }

// 非逃逸闭包
    func name(@noescape closures: (Int) -> Bool) {
        if closures(10) {
            return
        }
    }

// 自动闭包
    func name(@autoclosure(escaping) closures: () -> String) {
        customerProviders.append(closures)
    }
```

---

## 可选链


---

---

# 枚举

* 普通枚举
* 关联值 (实际上等于把每个 case 都变成可以储存值的元组类型。)
* 原始值 (以及其隐式赋值还有初始化)
* 递归枚举 (普通枚举并不能以自己作为值类型，但是递归枚举可以，使用 indirect)

```
// 普通枚举
    enum <name> {
        case <case>
        case <case>
        ...
    }

    enum <name> {
        case <value>, <value> ...
    }

    enum Type {
        case a
        case b
    }

    var type: Type = Type.a

// 关联值
    enum <name> {
        case <case>(<type>, <type>...)
        case <case>(<type or other type> ...)
    }

    enum Type {
        case a(Int)
        case b(String)
        case c(Int, Double)
    }

    var type: Type = Type.a(10)
    var type: Type = Type.b("Test")
    var type: Type = Type.c(10, 5.0)

// 原始值
    enum <name>: <type> {
        case <case> = <value>
        case <case> = <value>
        ...
    }

    enum <name>: <type> {
        case <case> = <value>, <case>, <case> = <value>, <case>...
    }

    enum Type: Int {
        case a = 1, b, c, d = 10, e, f
    }

    var type: Type = Type.b // rawValue = 2; Type.e.rawValue = 11
    var type: Type? = Type(rawValue: 12) // Type.f

// 递归枚举
    // 部分可使用递归
    enum <name> {
        case <case>(<type>)
        indirect case <case>(<name>)
    }
    // 全部可使用递归
    indirect enum <name> {
        case <case>(<type>)
        case <case>(<name>)
    }

    indirect enum Type {
        case a(Int)
        case b(Type)
    }

    indirect enum ArithmeticExpression {
        case number(Int)
        case addition(ArithmeticExpression, ArithmeticExpression)
        case multiplication(ArithmeticExpression, ArithmeticExpression)
    }

    let five = ArithmeticExpression.number(5)
    let four = ArithmeticExpression.number(4)
    let sum = ArithmeticExpression.addition(five, four)
    let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

    func evaluate(_ expression: ArithmeticExpression) -> Int {
        switch expression {
        case let .number(value):
            return value
        case let .addition(left, right):
            return evaluate(left) + evaluate(right)
        case let .multiplication(left, right):
            return evaluate(left) * evaluate(right)
        }
    }

    print(evaluate(product))
    // return ((5) + (4)) * (2)
    // 18
```

---

---

# 类和结构体

* 类
* 结构体
* 属性
* 方法
* 下标
* 继承
* 构造过程
* 析构过程
* 嵌套类型
* 扩展

## 类


---
<!--

    -->



## 结构体


---
<!--

    -->


## 属性


---
<!--

    -->


## 方法


---
<!--

    -->


## 下标


---
<!--

    -->


## 继承


---
<!--

    -->


## 构造过程


---
<!--

    -->


## 析构过程


---
<!--

    -->


## 嵌套类型


---
<!--

    -->


## 扩展


---
<!--

    -->

---
<!--

    -->


# 自动引用计数



---
<!--

    -->


---
<!--

    -->

# 错误处理


---
<!--

    -->


---
<!--

    -->

# 类型转换



---
<!--

    -->

---
<!--

    -->


# 协议



---
<!--

    -->

---
<!--

    -->


# 泛型


---
<!--

    -->

---
<!--

    -->


# 访问控制



---
<!--

    -->

---
<!--

    -->


# 指针



---
<!--

    -->

---
<!--

    -->



