---
layout: post
title: "Swift 3.0"
description: "记录 Swift 3.0 的笔记"
date: 2016-10-16
tags: [Swift]
comments: true
share: false
---

# 基础知识

## 类型

> Swift 基础类型以及集合类型都是值类型。

* 基础类型
    * Int
        * Int8
        * Int16
        * Int32
        * Int64
        * UInt
    * Double
    * Float
    * Bool
    * Character
    * String
* 集合类型
    * Array
    * Set
    * Dictionary
* 元组 (Tuple)
    * (,)
* 可选类型
    * nil

## 常量和变量

> Swift 带有类型推断功能，属性的类型可以注明，也可以通过初始值推断。


* 常量
    * let name: Type = value
    * let name = value
* 变量
    * var name: Type = value
    * var name = value
    * var name0 = value0, name1 = value1, name2 = value2
    * var name0, name1, name2: Type
* 命名规则
    * 可以使用 Unicode 字符作为名字。
    * 不能包含数学符号，箭头，保留或非法的 Unicode 码位，连线与制表符。
    * 不能以数字开头。

## 输出

public func print(_ items: Any..., separator: String = default, terminator: String = default)

## 注释

```
// 单行注释内容
/// Xcode 代码提示的单行注释内容
```

```
/*
    多行注释内容
 */
/**
    Xcode 代码提示的多行注释内容
 */
```

## 分号

Swift 不强制要求使用分号，但是也可以使用，比如在同一行内些多条独立语句的时候。

```
let cat = "🐱"; print(cat)
// 输出 "🐱"
```

## 数值型字面量

* 十进制数，没有前缀
* 二进制数，前缀是0b
* 八进制数，前缀是0o
* 十六进制数，前缀是0x

```
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

let paddedDouble = 000123.456      // 123.456
let oneMillion = 1_000_000         // 1000000
let justOverOneMillion = 1_000_000.000_000_1 // 1000000.0000001
```

## 类型转换

实际上 Swift 的类型转换应该是通过泛型的构造函数来初始化一个新类型的值，以此达到类型转换效果的。

## 类型别名

* typealias <New Type Name> = <Old Type Name>
* typealias AudioSample = UInt16

## 元组 (Tuples)

把多个值组合成为一个复合值，元组内部的值可以是任意类型，不要求是相同类型。

```
let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")

let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// 输出 "The status code is 404"
print("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"

let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"

print("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
print("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"

let http200Status = (statusCode: 200, description: "OK")

print("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
print("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
```

## 可选类型 (optional)

使用 ? 和 ! 来表示可选类型。

```
var value: Int?
value = nil // nil
value = 404 // 404?

if value == nil {
    // false
}

if let new = value {
    // new = 404
}

if let new1 = value1, let new2 = value2 {
    
}
```

## 错误处理 (error handing)

```
// 定义可能报错的函数
func canThrowAnError() throws {
    
}

// 调用该函数
do {
    try canThrowAnError()
    // 没有错误抛出
} catch {
    // 有错误抛出
}

## 断言

```
// 当 condition 为 true 则不会触发断言，否则就触发。
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)
```

---
<!--

    -->

---
<!--

    -->

# 运算符 (Operators)

* 基本运算符
* 高级运算符

## 基本运算符 (Basic Operators)

* 赋值运算符
    * =
* 正负号运算符
    * -
    * +
* 算术运算符
    * +
    * -
    * *
    * /
    * %
* 组合运算符
    * +=
    * -=
    * *=
    * /=
    * %=
* 三元运算符
    * condition ? trueReturn : falseRetrun
* 比较运算符
    * ==
    * !=
    * \>
    * <
    * >=
    * <=
    * ===
    * !==
* 空值运算符
    * opetionValue ?? ifvalue
* 区间运算符
    * ...
    * ..<
* 逻辑运算符
    * !
    * &&
    * ||

> String 类型也有 + 法运算，作用是拼接字符串。
> Swift 中可以对浮点数进行求余运算。

---
<!--

    -->


## 高级运算符

---
<!--

    -->

---
<!--

    -->

# 字符串与字符

* 字符串属性:
    * String 是 struct 类型
    * 字符串是值类型对象
* 字符串字面量: 
    * let some = "Some string literal value."
* 初始化空字符串: 
    * var empty = ""
    * var empty = String()
    * string.isEmpty // Bool
* 字符串可变性
    * empty += "Add new string"
* 单个字符
    * for character in string.characters { /* do some thing */ }
    * let char: Character = "!"
    * string = String([Character])
* 字符串操作
    * var string = "hello" + " there" // string = "hello there"
    * string += "!" // string = "hello there!"
    * string.append(Character)
* 字符串插值
    * var string = "\(some value) times is \(other value)"
* Unicode
    * 特殊字符
        * 转义字符
            * \0(空字符)
            * \\(反斜线)
            * \t(水平制表符)
            * \n(换行符)
            * \r(回车符)
            * \"(双引号)
            * \'(单引号)
        * Unicode 标量
            * \u{任意一到八位十六进制数且可用的 Unicode 位码}
* 字符串计数
    * string.characters.count
* 访问和修改字符串
    * String.Index 是 String 中 Character 位置的索引
        * 不直接使用 Index 是因为内部有 Unicode 码。
        * string.startIndex 字符串开头的位置
        * string.endIndex 字符串结束之后的位置
        * 使用 String.characters.indices 可以便利所有 index
            * for index in greeting.characters.indices {}
        * 访问: let string = "Test String!"
            * string[string.startIndex] // T
            * string[string.index(before: string.endIndex)] // !
            * string[string.index(after: string.startIndex)] // e
            * string[string.index(string.index, offsetBy: 5)] // S
            * string[string.endIndex] // 错误
            * string.index(after: endIndex) // 错误
    * 插入
        * string.insert(Characters, at: String.Index)
        * string.insert(contentsOf: String.characters, at: String.Index)
    * 删除
        * string.remove(at: String.Index) // 删除 Index 往前一个字符
        * string.removeSubrange(String.Index ..< String.Index)


---
<!--

    -->


# 集合类型

* Arrays, Sets, Dictionaries 类型是泛型集合
* Arrays, Sets, Dictionaries 的储存数据类型必须明确

## Arrays

* 数据类型: Array<Element>
* 创建
    * var ints = [Int]()        // {}
    * var ints: [Int] = []      // {}
    * var doubles = [Double](count: 3, repeatedValue: 0.0) // {0.0, 0.0, 0.0}
        * 如果 repeatedValue 参数填入某个类的初始化方法，也只会初始化一次，也就是所有下标都指向一个对象。
* 相加
    * var new = [Double](count: 2, repeatedValue: 0.0) + [Double](count: 2, repeatedValue: 2.0) // {0.0, 0.0, 2.0, 2.0}
        * 实际上是创建一个新数组，而不是拼接，有内存消耗。
* 访问
    * count         // 数量
    * isEmpty       // 检查 count 是否为 0
    * append(_:)    // 添加元素
    * +=            // 添加数组
    * array[Int]    // 下标访问某元素
    * array[2...3]  // 使用 Range 获取子数组
* 操作
    * append(_ newElement: Element)
    * insert(_ newElement: Element, at i: Int)
    * remove(at index: Int) -> Element
    * removeLast() -> Element
* 遍历
    * for item in array { /* do some thing */ }
    * for (index, item) in array.enumerate() { /* do some thing */ }

## Sets

* 集合类型必须是可哈希化的
* 数据类型: Set<Element>
* 创建
    * var letters = Set<Character>()
    * var letters: Set<Character> = []
    * var letters: Set<String> = ["AString", "BString"]
    * var letters = ["AString", "BString"]
* 访问
    * isEmpty
* 操作
    * insert(_ newElement: Element)
    * remove(_:)
    * removeAll()
    * contains(_:)
* 遍历
    * for item in set { /* do some thing */ }
    * for item in set.sort { /* do some thing */ } // 按顺序排序
* 集合操作
    * a.intersection(b)        // a b 相交的所有元素
    * a.symmetricDifference(b) // a b 所有的元素，但不包含重复的元素
    * a.union(b)               // a b 合并的所有元素
    * a.subtracting(b)         // a 中 b 没有的元素
* 集合运算
    * == // 是否完全一致
    * a.isSubset(of: b)         // a 中的元素 b 是否都有
    * a.isSuperset(of: b)       // b 中的元素 a 是否都有
    * a.isStrictSubset(of: b)   // a 中的元素 b 是否都有，并且 a != b
    * a.isStrictSuperset(of: b) // b 中的元素 a 是否都有，并且 a != b
    * a.isDisjoint(with: b)     // a b 是否没有交集


## Dictionaries

* key 必须遵守 Hashable 协议
* 数据结构: Dictionary<Key, Value>
* 创建
    * var dic = [Int: String]()
    * var dic: [Int: String] = [:]
    * var dic = [0: "A", 1: "B"]
* 访问和修改
    * dic[0] = "C" // 新增或修改 [0]
    * dic[0] = nil // 删除 [0]
    * isEmpty
    * updateValue(_, forKey:) -> Value?
    * removeValue(forKey: ) -> Value?
* 遍历
    * for (key, value) in dic { /* do some thing */ }
    * for key in dic.keys.sorted() { /* do some thing */ }
    * for value in dic.values.sorted() { /* do some thing */ }


---
<!--

    -->

---
<!--

    -->

# 控制流

* 循环
    * for-in

```
for _ in 0 ..< 10 {
    /* do some thing */
}
```

    * while

```
while condition {
    /* do some thing */
}

repeat {
    /* do some thing */
} while condition
```

* 条件语句
    * if 

```
if condition {
    /* do some thing */
} else if condition {
    /* do some thing */
} else {
    /* do some thing */
}
```

    * switch

```
switch status {
case .a:
    /* do some thing */
case .b:
    /* do some thing */
default:
    /* do some thing */
}

switch value {
case 0, 20:
    /* do some thing */
case 1 ..< 5:
    /* do some thing */
    fallthrough
case 5 ..< 10:
    /* do some thing */
default:
    /* do some thing */
}

switch tuple {
case (0, 0):
    /* do some thing */
case (_, 1):
    /* do some thing */
case (0 ..< 5, 8 ..< 10):
    /* do some thing */
case (let x, 9):
    /* do some thing */
case let (x, y):
    /* do some thing */
case let (x, y) where x == y:
    /* do some thing */
default:
    /* do some thing */
}
```

    * guard

```
guard let v = value else { 
    return 
}
```


* 控制转移语句
    * continue
    * break
    * fallthrough
    * return
    * throw
    * labelName: while condition { statements }
        * break labelName
        * continue labelName

* Api 检查



---
<!--

    -->

---
<!--

    -->

# 函数与闭包及其调用

* 函数
* 闭包
* 可选链

## 函数


---
<!--

    -->

## 闭包


---
<!--

    -->

## 可选链


---
<!--

    -->

# 枚举


---
<!--

    -->


# 类和结构体

* 类
* 结构体
* 属性
* 方法
* 下标
* 继承
* 构造过程
* 析构过程
* 嵌套类型
* 扩展

## 类


---
<!--

    -->



## 结构体


---
<!--

    -->


## 属性


---
<!--

    -->


## 方法


---
<!--

    -->


## 下标


---
<!--

    -->


## 继承


---
<!--

    -->


## 构造过程


---
<!--

    -->


## 析构过程


---
<!--

    -->


## 嵌套类型


---
<!--

    -->


## 扩展


---
<!--

    -->

---
<!--

    -->


# 自动引用计数



---
<!--

    -->


---
<!--

    -->

# 错误处理


---
<!--

    -->


---
<!--

    -->

# 类型转换



---
<!--

    -->

---
<!--

    -->


# 协议



---
<!--

    -->

---
<!--

    -->


# 泛型


---
<!--

    -->

---
<!--

    -->


# 访问控制



---
<!--

    -->

---
<!--

    -->


# 指针



---
<!--

    -->

---
<!--

    -->



