---
layout: post
title: "Swift 3.0"
description: "记录 Swift 3.0 的笔记"
date: 2016-10-16
tags: [Swift]
comments: true
share: false
---

# 基础知识

* 类型
* 常量和变量
* 输出
* 注释
* 分号
* 数值型字面量
* 类型别名
* 元组
* 可选类型
* 错误处理

---

## 类型

> Swift 基础类型以及集合类型都是值类型。

* 基础类型
    * Int (Int8, Int16, Int32, Int64, UInt...)
    * Double (Float)
    * Bool
    * String (Character)
* 集合类型
    * Array
    * Set
    * Dictionary
* 元组 (Tuple)
    * (,)
* 可选类型
    * nil

## 常量和变量

> Swift 带有类型推断功能，属性的类型可以注明，也可以通过初始值推断。

* 常量: let <name>: <type> = <value>
* 变量: var <name>: <type><!,? or noting> = <value>

## 输出

```
public func print(_ items: Any..., separator: String = default, terminator: String = default)
```

## 注释

```
// 单行注释内容
/// 带 Xcode 代码提示的单行注释内容

/*
    多行注释内容
 */
/**
    带 Xcode 代码提示的多行注释内容
 */
```

## 分号

Swift 不强制要求使用分号，但是也可以使用，比如在同一行内些多条独立语句的时候。

## 数值型字面量

* 十进制数，没有前缀
* 二进制数，前缀是0b
* 八进制数，前缀是0o
* 十六进制数，前缀是0x

```
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

let paddedDouble = 000123.456      // 123.456
let oneMillion = 1_000_000         // 1000000
let justOverOneMillion = 1_000_000.000_000_1 // 1000000.0000001
```

## 类型别名

```
// typealias <New Type Name> = <Old Type Name>
typealias AudioSample = UInt16
```

## 元组 (Tuples)

把多个值组合成为一个复合值，元组内部的值可以是任意类型，不要求是相同类型。

```
let http404Error = (404, "Not Found")
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")

let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// 输出 "The status code is 404"
print("The status message is \(statusMessage)")
// 输出 "The status message is Not Found"

let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// 输出 "The status code is 404"

print("The status code is \(http404Error.0)")
// 输出 "The status code is 404"
print("The status message is \(http404Error.1)")
// 输出 "The status message is Not Found"

let http200Status = (statusCode: 200, description: "OK")

print("The status code is \(http200Status.statusCode)")
// 输出 "The status code is 200"
print("The status message is \(http200Status.description)")
// 输出 "The status message is OK"
```

## 可选类型 (optional)

使用 ? 和 ! 来表示可选类型。? 表示使用的时候可能为 nil, ! 表示使用的时候自动解包。

## 错误处理 (error handing)

```
// 定义可能报错的函数
func canThrowAnError() throws {
    
}

// 调用该函数
do {
    try canThrowAnError()
    // 没有错误抛出
} catch {
    // 有错误抛出
}
```

## 断言

```
// 当 condition 为 true 则不会触发断言，否则就触发。
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)
```

---

---

# 运算符 (Operators)

* 基本运算符
* 高级运算符

## 基本运算符 (Basic Operators)

* 赋值运算符 ( = )
* 正负号运算符 ( -, + )
* 算术运算符 ( +, -, *, /, % )
* 组合运算符 ( +=, -=, *=, /=, %= )
* 三元运算符 ( <条件> ? <true 返回值> : <false 返回值> )
* 比较运算符 ( ==, !=, >, <, >=, <=, ===, !== )
* 空值运算符 ( <可选类型> ?? <假如可选类型为空时的返回值> )
* 区间运算符 ( ..., ..< )
* 逻辑运算符 ( !, &&, || )

> Swift 中可以对浮点数进行求余运算。

---

## 高级运算符

---

---

# 字符串与字符

> 字符串是 struct 类型

```
// 字符
    let <name>: Character = "!"

// 初始化
    var <name>: String = String()
    var <name>: String = "Some String \(<value>) Other String"

// 字符串常用操作
    /*
        * 运算符 ( +, += )
        * 函数操作 ( append(), insert(), remove(), removeSubrange() )
        * 获取字符及字符数量 ( String.characters, String.characters.count )
    */

// Unicode
    /*
        * 转义字符
            * \0(空字符)    \\(反斜线)    \t(水平制表符)
            * \n(换行符)    \r(回车符)    \"(双引号)    \'(单引号)
        * Unicode 标量
            * \u{任意一到八位十六进制数且可用的 Unicode 位码}
    */

// String.Index 字符串索引
    let test = "This is a long String, and is end!"
                ^                                 ^
                test.startIndex                   test.endIndex
    // * 利用下标访问字符串
    test[test.startIndex]                       // T
    test[test.index(before: test.endIndex)]     // !
    test[test.index(after: test.startIndex)]    // h
    test[test.index(test.index, offsetBy: 5)]   // s
    test[test.endIndex]                         // 错误
    test.index(after: test.endIndex)            // 错误
    test[test.startIndex ..< test.index(test.startIndex, offsetBy: 6)] // This i

    // * 遍历下标
    for index in test.characters.indices {
        print(test[index])
    }
    // This is a long String, and is end!
```

---

---


# 集合类型

* Arrays
* Sets
* Dictionaries 

> Swift 中集合类型都是泛型
> 集合类型的数据类型必须明确

## Array<Element>

```
// 创建
    var <name>: [<type>] = [Type](count: <number>, repeatedValue: <init value>)

// 访问
    <array>[<index>]
    <array>[<Range>]

// 常用操作
    /*
        * 运算符 ( +, += )
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( append(), insert(), remove(), removeAll(), removeLast(), removeFirst() )
    */

// 遍历
    for value in array {
        /* do some thing */
    }

    for (index, value) in array.enumerate() {
        /* do some thing */
    }
```

---

## Set<Element>

> 集合类型必须遵守 Hashable 协议

```
// 创建
    var <name>: Set<<type>> = Set<<type>>()

// 常用操作
    /*
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( insert(), remove(), removeAll(), removeFirst(), contains() )
    */

// 遍历
    for value in set {
        /* do some thing */
    }

    for (index, value) in set.sorted() {
        /* do some thing */
    }

// 集合操作
    var a: Set<Int> = [1,2,3,4,5]
    var b: Set<Int> = [3,4,5,6,7]
    a.intersection(b)        // [3,4,5]         相交元素
    a.symmetricDifference(b) // [1,2,6,7]       非相交元素
    a.union(b)               // [1,2,3,4,5,6,7] 所有元素
    a.subtracting(b)         // [1,2]           a 中的非相交元素

// 集合运算
    * ==                        // 是否完全一致
    * a.isSubset(of: b)         // a 中的元素 b 是否都有
    * a.isSuperset(of: b)       // b 中的元素 a 是否都有
    * a.isStrictSubset(of: b)   // a 中的元素 b 是否都有，并且 a != b
    * a.isStrictSuperset(of: b) // b 中的元素 a 是否都有，并且 a != b
    * a.isDisjoint(with: b)     // a b 是否没有交集
```

---

## Dictionary<Hashable, Any>

> key 必须遵守 Hashable 协议

```
// 创建
    var <name>: Dictionary<<key type>, <value type>> = Dictionary<<key type>, <value type>>()

// 访问和修改
    <dic>[<key>] = <Any>? // 如果 Any 不为空则是新增或修改 key 值，否则就是删除 key 值。

// 常用操作
    /*
        * 常用属性 ( count, isEmpty )
        * 常用方法 ( updateValue(), remove(), removeValue(), removeAll(), contains() )
    */

// 遍历
    for (key, value) in dic {
        /* do some thing */
    }

    for key in dic.keys.sorted() {
        /* do some thing */
    }

    for value in dic.values.sorted() {
        /* do some thing */
    }
```

---

---

# 控制流

* 循环
* 分支
* 控制转移语句

## 循环

```
// for-in

    for <value or _> in <array like 0 ..< 10, or [1,2,3]> {
        /* do some thing */
    }

// while

    while <条件> {
        /* do some thing */
    }

    repeat {
        
    } while <条件>

```

---

## 分支

```
// if

if <条件> {
    /* do some thing */
} else if <条件> {
    /* do some thing */
} else {
    /* do some thing */
}

// switch

    switch <值> {
    case <条件>:
        /* do some thing */
    case <条件>:
        /* do some thing */
    default:
        /* do some thing */
    }

    // 各种示例
        let value: Int = 10
        switch value {
        case 0: // 单一匹配
            /* do some thing */
        case 1, 2, 3: // 复合匹配
            /* do some thing */
        case 4 ..< 7: // 区间匹配
            /* do some thing */
        default:
            /* do some thing */
        }

        let tuple: (Int, Int) = (10, 10)
        switch tuple {
        case (0, 0): // 单一匹配
            /* do some thing */
        case (1, 1), (2, 2):            // 复合匹配
            /* do some thing */
        case (3 ..< 5, 4 ..< 6):        // 区间匹配
            /* do some thing */
        case (_, 7), (8, _):            // _ 匹配所有值，表示忽略
            /* do some thing */
        case (let x, 9):                // 忽略并获取 $0 值
            /* do some thing */
        case let (x, y):                // 忽略并获取 $0, $1 值
            /* do some thing */
        case let (x, y) where x == 7:   // 使用 where 添加限定条件
            /* do some thing */
        default: 
            /* do some thing */
        }

// guard

    guard <条件> else {
        <必须有 retrun, continue 等退出条件>
    }

    // 解包
    guard let <value> = <value>? else {
        <必须有 retrun, continue 等退出条件>
    }
```

---

##  控制转移语句

```
// continue 跳过当前循环中的后面部分，直接进入下一次循环

// break 跳出当前的循环

// return 退出当前的函数

// fallthrough switch 语句中使用，让某个 case 可以进入下一个 case.

// throw 错误抛出

// 循环标签

    <name>: while <条件> {
        /* do some thing */
        <name2>: while <条件> {
            /* do some thing */
            break name // 直接退出 name 循环
        }
    }

// Api 检查

    if #available(<platform name> <version>, <...>, *) {
        // statements to execute if the APIs are available
    } else {
        // fallback statements to execute if the APIs are unavailable
    }

    if #available(iOS 10, macOS 10.12, *) {
        /* iOS 使用 iOS 10 的 API, macOS 使用 macOS 10.12 的 API */
    } else {
        /* 其他版本的 Api */
    }

```

---

---

# 函数与闭包及其调用

* 函数
* 闭包
* 可选链

## 函数

函数定义: func <name>(<参数外部名> <参数内部名>: <inout> <参数类型> = <默认值> <可变参数 ...>) -> <返回值类型>

函数类型: (<参数类型>) -> <返回值参数>

嵌套函数: 函数中可以定义函数，该函数只有在函数内部有效。

---

## 闭包

闭包是自包含的代码库，可以在代码中被传递和使用。闭包可以捕获和存储其所在上下文中任意的常量和变量来使用，所以会导致引用计数 +1 从而有循环引用的风险。

全局函数是一个有名字但不会捕获任何值的闭包。嵌套函数是有名字并可以捕获函数内值的闭包。闭包表达式一般都是匿名闭包。

单表达式的闭包可以省略 retrun 关键字。

闭包内的参数在未定义的情况下可以使用 $0 来对参数名称进行缩写，$0 表示第一个参数， $1 表示第二个参数，以此类推。

闭包是引用类型的值。

@noescape 表示非逃逸闭包，限定了闭包的生命周期只能存在于当前函数当中。

@autoclosure 表示自动闭包，这种闭包不接受参数，并且由返回值。用于传递作为参数的表达式，并可以省略花括号。自动闭包都默认带了 noescape 属性，如果想要声明为可逃逸闭包则是 @autoclosure(escaping).

```
{ (<参数名>: <参数类型>) -> <返回值类型> in
    <闭包实现>
}

闭包在使用的时候可以有几种不同的方式，以 sorted 调用为例: 
    // 完整
    closures.sort(by: { (v0: Int, v1: Int) -> Bool in
        return v0 > v1
    })

    // 上下文推断
    closures.sort(by: { v0, v1 in
        return v0 > v1
    })

    // 隐式返回值
    closures.sort(by: { $0 > $1 })

    // 运算符函数返回
    closures.sort(by: >)

    // 尾闭包
    closures.sort { $0 > $1 }

// 非逃逸闭包
    func name(@noescape closures: (Int) -> Bool) {
        if closures(10) {
            return
        }
    }

// 自动闭包
    func name(@autoclosure(escaping) closures: () -> String) {
        customerProviders.append(closures)
    }
```

---

## 可选链

```
if let <value> = <object>.<value>?.<function>?.<dictionary>[<key>]?.<array>[<index>] {
    /* 只要其中有 1 个 nil, 就会返回 nil, 否则会逐层解压。*/
    /* 利用可选链的特性，可以实现链式编程。 */
}
```

---

---

# 枚举

* 普通枚举
* 关联值 (实际上等于把每个 case 都变成可以储存值的元组类型。)
* 原始值 (以及其隐式赋值还有初始化)
* 递归枚举 (普通枚举并不能以自己作为值类型，但是递归枚举可以，使用 indirect)

```
// 普通枚举
    enum <name> {
        case <case>
        case <case>
        ...
    }

    enum <name> {
        case <value>, <value> ...
    }

    enum Type {
        case a
        case b
    }

    var type: Type = Type.a

// 关联值
    enum <name> {
        case <case>(<type>, <type>...)
        case <case>(<type or other type> ...)
    }

    enum Type {
        case a(Int)
        case b(String)
        case c(Int, Double)
    }

    var type: Type = Type.a(10)
    var type: Type = Type.b("Test")
    var type: Type = Type.c(10, 5.0)

// 原始值
    enum <name>: <type> {
        case <case> = <value>
        case <case> = <value>
        ...
    }

    enum <name>: <type> {
        case <case> = <value>, <case>, <case> = <value>, <case>...
    }

    enum Type: Int {
        case a = 1, b, c, d = 10, e, f
    }

    var type: Type = Type.b // rawValue = 2; Type.e.rawValue = 11
    var type: Type? = Type(rawValue: 12) // Type.f

// 递归枚举
    // 部分可使用递归
    enum <name> {
        case <case>(<type>)
        indirect case <case>(<name>)
    }
    // 全部可使用递归
    indirect enum <name> {
        case <case>(<type>)
        case <case>(<name>)
    }

    indirect enum Type {
        case a(Int)
        case b(Type)
    }

    indirect enum ArithmeticExpression {
        case number(Int)
        case addition(ArithmeticExpression, ArithmeticExpression)
        case multiplication(ArithmeticExpression, ArithmeticExpression)
    }

    let five = ArithmeticExpression.number(5)
    let four = ArithmeticExpression.number(4)
    let sum = ArithmeticExpression.addition(five, four)
    let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

    func evaluate(_ expression: ArithmeticExpression) -> Int {
        switch expression {
        case let .number(value):
            return value
        case let .addition(left, right):
            return evaluate(left) + evaluate(right)
        case let .multiplication(left, right):
            return evaluate(left) * evaluate(right)
        }
    }

    print(evaluate(product))
    // return ((5) + (4)) * (2)
    // 18
```

---

---

# 类和结构体

* 类
* 结构体
* 属性
* 方法
* 下标
* 继承
* 构造过程
* 析构过程
* 嵌套类型
* 扩展

* 类与结构体的差异:
    * 类是引用类型，结构体是值类型;
    * 结构体不允许继承;
    * 结构体不能类型转换;
    * 结构体没有析构器;
* 符合以下条件可以考虑使用结构体而不是类:
    * 主要封装少量简单数据
    * 被传递或赋值的时候希望是拷贝而不是引用
    * 封装的值也希望是拷贝而不是引用
    * 不需要继承

## 类

> 可以使用 (===) 以及 (!==) 判断两个类是否是同一个对象。

```
class <name>: <super class>, <protocol> {

    /** 属性 **/
    var <name>: <type> = <value or no>      // 存储属性
    lazy var <name>: <type> = <value>       // 延迟属性
    static var <name>: <type> = <value>     // 类型属性，静态属性
    let <name>: <type> = {                  // 通过闭包对值进行初始化, let var 都行
        return <value>
    }()
    var <name>: <type> {                    // 计算属性，不存储内容
        get {
            /* 只读属性可以不写 get {}, 直接 return */
            return <value>
        }
        set(newValue) {
            /* set 属性可以不设置，则是只读属性 */
        }
    }
    var <name>: <type> = <value> {          // 添加属性观察器
        didSet {
            /* ... */
        }
        willSet {
            /* ... */
        }
    }

    /** 方法 **/
    func <name>(...) {                      // 实例方法

    }
    override func <father func name>(...) { // 重写方法

    }
    class func <name>(...) {                // 类方法

    }

    /** 下标 **/
    subscript(...) -> <type> {
        get {
            return <value>
        }
        set(newValue) {
            /* ... */
        }
    }

    /** 构造器和析构器**/
    init(...) {
        // super.init(...)
    }
    convenience init(...) {
        /* ... */
        self.init(...)
    }
    deinit {

    }
}
```

---

## 结构体

```
struct <name>: <protocol> {

    /** 属性 **/
    var <name>: <type> = <value or no>      // 存储属性
    lazy var <name>: <type> = <value>       // 延迟属性
    var <name>: <type> {                    // 计算属性，不存储内容
        get {
            /* 只读属性可以不写 get {}, 直接 return */
            return <value>
        }
        set(newValue) {
            /* set 属性可以不设置，则是只读属性 */
        }
    }
    var <name>: <type> = <value> {          // 添加属性观察器
        didSet {
            /* ... */
        }
        willSet {
            /* ... */
        }
    }
    static var <name>: <type> = <value>     // 类型属性，静态属性


    /** 方法 **/
    func <name>(...) {

    }
    mutating func <name>(...) {

    }
    static func <name>(...) {

    }

    /** 下标 **/
    subscript(...) -> <type> {
        get {
            return <value>
        }
        set(newValue) {
            /* ... */
        }
    }

    /** 构造器 **/
    init(...) {
        // super.init(...)
    }
}


```

---


## 属性

* 储存属性 let var
* 延迟属性 lazy
* 计算属性 set get
* 属性监听器 didSet willSet
* 静态属性 static
* 全局属性默认是延迟计算的

## 方法

* 实例方法 (struct 中修改到值属性的方法需要添加 mutating)
* 类型方法

## 下标

subscript()

## 继承

* 重写(override): 继承之后可以使用重写关键字来重写父类的方法 
    * 方法
    * 属性 
    * 属性观察器
    * 构造器
* 调用父类(super): 在重写的方法或属性中可以通过 super. 来调用父类的变量或函数。
* 防止重写(final): 子类再不能重写它。
    * 属性 final var
    * 方法 final func
    * 不可继承类 final class

---

## 构造过程

* 储存属性在构建实例的时候必须被初始化，可选属性可以被自动初始化成 nil
    * 常量属性可以等到构造过程进行设置
* 不带外部名的构造器参数 init(_ value: Int)
* class 和 strut 都提供了默认构造器
    * strut 构造器中可以调用其他构造器 self.init(...)
    * class 构造器中可以使用父类构造器 super.init(...)
    * convenience 便捷构造器，在该构造器中需要调用其他构造器
* init?(...) init!(...) 可失败构造器，在当中返回 nil 表示失败
    * 可以在子类中使用非可失败构造器重写父类的可失败构造器
* required init() 必要构造器，子类必须要重写构造器

* 构造器规则
    * 指定构造器必须调用其父类的指定构造器 (或默认调用的 super.init())
    * 便捷构造器必须调用该类的其他构造器。

* 两段式构造过程中构造流程展示：
    * 阶段 1
        * 某个指定构造器或便利构造器被调用。
        * 完成新实例内存的分配，但此时内存还没有被初始化。
        * 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。
        * 指定构造器将调用父类的构造器，完成父类属性的初始化。
        * 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。
        * 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。
    * 阶段 2
        * 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。
        * 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。

---

## 析构过程

析构器会在实例释放发生之前被自动调用。

---


## 嵌套类型


---
<!--

    -->


## 扩展


---
<!--

    -->

---
<!--

    -->


# 自动引用计数 (ARC)

* 默认引用都是强引用
* weak var <name>: <Type>? 使用 weak 来进行弱引用，弱应用都是 optional 值。
* unowned var <name>: <Type> 使用 unowned 来进行无主引用，同样是弱引用，但是非 optional 值，所以在实例被释放后，再使用会导致错误。
* 如果确定在使用期间肯定不会被释放，应该用 unowned，否则使用 weak
* 闭包捕获默认是强引用，通过定义闭包的捕获列表可设置弱引用。

```
var <closure>: (<type>...) -> <return type> = {
    [unowned <value>, weak <value> = self.value] (<value>: <type>...) -> <return type> in
    ...
    return ...
}

lazy var closure: (Int, String) -> String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
    return ...
}
```

---
<!--

    -->


---
<!--

    -->

# 错误处理


---
<!--

    -->


---
<!--

    -->

# 类型转换



---
<!--

    -->

---
<!--

    -->


# 协议



---
<!--

    -->

---
<!--

    -->


# 泛型


---
<!--

    -->

---
<!--

    -->


# 访问控制



---
<!--

    -->

---
<!--

    -->


# 指针



---
<!--

    -->

---
<!--

    -->



